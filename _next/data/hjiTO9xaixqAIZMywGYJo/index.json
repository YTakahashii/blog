{"pageProps":{"posts":[{"slug":"opening-a-blog","title":"Next.jsで技術ブログを作った話","publishDate":"2021-08-15","coverImage":"","excerpt":"Next.jsを使って技術ブログを作りました。使用した技術スタックと実装や学びについて共有します。","ogImage":{"url":"https://og-image-for-blog.vercel.app/**Next.jsで技術ブログを作った話**.png?theme=light&md=1&fontSize=100px"},"content":"\n**世はまさに、自作技術ブログ時代！** という訳で、Next.js 等を使って技術ブログを作りました。\n\n一旦、きりの良いところまで実装が終わったので、公開しようと思います！\n\nこのブログでは、趣味で触った技術のことについて、ざっくばらんに記事を投稿していく予定です。\nまた、私は Web Frontend が好きなので、関連技術の実験場にも活用していきます。\n\nゴールデンウィークから作り始めて、休日にちまちまやっていたので、随分時間がかかってしまいましたが、いい感じに仕上がってとりあえず満足しています。\n\n<blockquote class=\"twitter-tweet\"><p lang=\"ja\" dir=\"ltr\">ゴールデンウィークなので、ブログを作りはじめた <a href=\"https://t.co/wpIXkEehwl\">pic.twitter.com/wpIXkEehwl</a></p>&mdash; yuchan (@Wakeupsloth) <a href=\"https://twitter.com/Wakeupsloth/status/1389551048017080322?ref_src=twsrc%5Etfw\">May 4, 2021</a></blockquote>\n\n以降のセクションでは、技術スタックと、実装に一番の時間を要した Markdown ファイルから React コンポーネントに変換するまでの処理の詳細について振り返ります。\n\n### 技術スタック\n\n本ブログの開発に使用した技術は以下の通りです。（みんな使ってそうな構成）\n\n- [Next.js](https://nextjs.org/)：言わずと知れた React のフレームワーク\n- [Chakra UI](https://chakra-ui.com/)：tailwind like に React コンポーネントのスタイリングができるコンポーネントライブラリ\n- [jonschlinkert/gray-matter](https://github.com/jonschlinkert/gray-matter)：Markdown に yaml でメタ情報を埋め込めるやつ\n- [unifiedjs/unified](https://github.com/unifiedjs/unified)：構文木を使用してテキストを処理するためのインターフェース\n- [shiki](https://shiki.matsu.io/)：コードハイライター\n- [vercel/og-image](https://github.com/vercel/og-image)：OGP 画像の生成\n- [GitHub Pages](https://pages.github.com/)：サイトのホスティング\n\n## やったこと＆学び\n\n最初のゴールとして、Markdown から記事を生成可能かつ、それを見てもらうための最低限の機能に絞って開発を進めました。\nやったことを大別すると以下の 3 つになるのかなと思います。\n\n- Markdown ファイルからの記事ページ生成とレイアウト設定\n  - MD を変換する処理を実装することで、構文木の世界を学べた\n- プライベート記事機能\n  - [ブログのトップページ](/)や Google 検索の結果に載せないプライベート記事（例：[Playground](/_playground)）を公開する機能\n- メタタグの設定\n  - これまで業務的な Web アプリばかりを開発してきたため、学びが多かった\n\n## Markdown ファイルの内容を React コンポーネントに変換する\n\n### 1．Next.js で全 Markdown ファイルを取得して記事ページを生成する\n\n記事ページの生成は Next.js の SSG を使います。\n\n具体的には、[pages/[slug].tsx](https://github.com/YTakahashii/blog/blob/573224fa61a263d26c861aaea6696ad22f0a5469/src/pages/%5Bslug%5D.tsx#L1)内で、 `getStaticPaths` を使って Markdown のファイル名から記事ページの URL を生成し、\n\n```tsx\nexport const getStaticPaths: GetStaticPaths<Params> = async () => {\n  const posts = getAllPosts('all');\n\n  return {\n    paths: posts.map((post) => ({\n      params: {\n        slug: post.slug,\n      },\n    })),\n    fallback: false,\n  };\n};\n```\n\n`getStaticProps` を使って render する 記事の情報を取得し、Page コンポーネントの Props として渡します。\n\n```tsx\nexport const getStaticProps: GetStaticProps<{ post: Post }, Params> = async ({ params }) => {\n  const post = getPostBySlug(params.slug);\n\n  const html = await markdownToHtml(post.content ?? '');\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content: html,\n      },\n    },\n  };\n};\n```\n\n### 2．unified で Markdown を整形して HTML の文字列に変換する\n\n上記の `getPostBySlug()` では、Markdown ファイルの中身（`post.content`）を文字列で取得します。\n\n続く`markdownToHtml()`では、`unified` を使って、ファイルの中身を HTML の文字列に変換していきます。\n\n```ts\nexport async function markdownToHtml(markdown: string) {\n  const result = unified()\n    .use(remarkParse)\n    .use(remarkRehype, { allowDangerousHtml: true })\n    .use(rehypeRaw)\n    .use(rehypeShiki, {\n      highlighter: await getHighlighter({\n        theme: 'github-dark',\n      }),\n    })\n    .use(rehypeStringify)\n    .processSync(markdown);\n\n  return result.toString();\n}\n```\n\n変換処理の概要は以下の通りです。\n\n- `remarkParse`：Markdown の文字列を[mdast](https://github.com/syntax-tree/mdast)（Markdown Abstract Syntax Tree format）に変換する\n- `remarkRehype`：mdast を [hast](https://github.com/syntax-tree/hast)（Hypertext Abstract Syntax Tree format）に変換する，`{ allowDangerousHtml: true }` により、生の HTML はそのまま残す\n- `rehypeRaw`：hast 内の生 HTML を hast に変換する\n- `rehypeShiki`：コードハイライターの shiki を使って 複数行のコードブロック をハイライトするスタイルを適用する\n- `rehypeStringify`：hast を HTML の文字列に変換する\n\n### 3．HTML の文字列を React コンポーネントに変換する\n\n最後に `markdownToHtml()` で取得した HTML 文字列を [remarkjs/react-markdown](https://github.com/remarkjs/react-markdown)を使って React コンポーネントに変換します。（[components/markdowns/Markdown.tsx](https://github.com/YTakahashii/blog/blob/main/src/components/markdowns/Markdown.tsx)）\n\n```tsx\nimport ReactMarkdown from 'react-markdown';\nimport rehypeRaw from 'rehype-raw';\nimport * as components from 'src/components/markdowns/_components';\n\n...\n\nexport const Markdown: React.VFC<Props> = ({ rawHtml }) => (\n  <ReactMarkdown rehypePlugins={[rehypeRaw]} children={rawHtml} components={components} />\n);\n```\n\nこのとき、`components` に React コンポーネントを渡すことで、任意のタグを自由に変換することができます。今回は、変換するコンポーネントを[components/markdowns/\\_components]()の中に定義しました。\n\n変換する対象は、[`<table />`](https://github.com/YTakahashii/blog/blob/573224fa61a263d26c861aaea6696ad22f0a5469/src/components/markdowns/_components/table.tsx#L1)のように、Chakra UI のコンポーネントに置き換えるタグと、[`<a />`](https://github.com/YTakahashii/blog/blob/573224fa61a263d26c861aaea6696ad22f0a5469/src/components/markdowns/_components/a.tsx#L1)のように、Props に応じて、レンダリングするコンポーネントを出し分けるタグです。\n\nスタイルだけ当てたいタグについてはここでは変換せず、 [Chakra UI のテーマを設定](https://github.com/YTakahashii/blog/blob/main/src/theme/index.ts)しました。\n\nまた、今回は変換対象の文字列（`children`）が HTML の形式であるため、`rehypePlugins` に `rehypeRaw` を指定して、hast に変換する処理を加える必要がありました。ピュアな MD 形式の文字列である場合は、`rehypeRaw` は不要です。\n\n## 今後実装したい機能\n\n- タグ機能\n  - 記事が増えていくにつれて探すのが大変になりそうなので、そのうち実装したいお気持ち\n- 目次機能\n  - この記事みて思ったけど、やっぱり目次あったほうが見やすいですね\n- ダークモードや PWA\n  - 新しい Web の機能をどんどん使っていきたいお気持ち\n- カッコいい OGP 画像の作成\n  - 今のデザインが超適当なので、どこかで気合を入れて作り込みたい\n\n## おわりに\n\nこれからは、ブログをもっと良くしたり、学んだ内容を定期的にアウトプットしていきたいと思います！\n\n最初は、「ブログなんて今更自分で作ってもな〜」とか思ってたのですが、車輪の再発明をすることで学べることも多いなと感じました。\n","url":"https://ytakahashii.github.io/blog/opening-a-blog","isPrivate":false}]},"__N_SSG":true}