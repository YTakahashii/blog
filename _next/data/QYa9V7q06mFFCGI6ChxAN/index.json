{"pageProps":{"posts":[{"slug":"lerning-from-redux-essentials-part1","title":"Redux Essentials から学ぶ Part1：Modern Redux とパフォーマンス最適化","publishDate":"2021-09-25","coverImage":"","excerpt":"公式チュートリアルの Redux Essentials を読みながら、JavaScript を TypeScript に変換しつつ写経することで、redux-toolkit を使ったモダンな 書き方や RTK Query について学びました。","ogImage":{"url":"https://raw.githubusercontent.com/YTakahashii/blog/47bc1570103ff3178de2d5ba2e3376d5b3b9df04/public/assets/blog/lerning-from-redux-essentials-part1/ogimage.png"},"content":"\nアプリケーションの状態管理は、フロントエンド開発で注目されているトピックの 1 つです。\nReact のグローバル状態管理ライブラリといえば、2，3 年前は Redux 一強でしたが、2021 年現在は、[Apollo Client](https://www.apollographql.com/docs/react/), [Recoil](https://recoiljs.org/), [jotai](https://jotai.pmnd.rs/), [SWR](https://swr.vercel.app/) 等、様々なものがあります。\n\n私は、2020 年の 3 月頃まで約 2 年ほど Redux を使った開発を経験していましたが、その後は SWR や Apollo Client を採用したプロジェクトで開発していたため、しばらく Redux から離れていました。\nですが、この度新卒エンジニアとして、9 月から Redux を使っているプロダクトの開発チームに本配属され、再び Redux と真剣に向き合うことになりました！\n\nそんな中、先日参加した[Souzoh Tech Talk #03: Frontend](https://mercari.connpass.com/event/221978/)の中で紹介された、[\"feature pattern\"](https://redux.js.org/style-guide/style-guide#structure-files-as-feature-folders-with-single-file-logic) という Redux 推奨のディレクトリ構成の話がきっかけで、Redux のドキュメントが 2020 年当時より大幅にアップデートされていることを知りました。\n\nこれは Redux を学び直す良い機会だなと思い、ここ 1 週間くらい、公式チュートリアルの Redux Essentials を読みながら、JavaScript を TypeScript に変換しつつ写経することで、redux-toolkit を使ったモダンな 書き方や RTK Query について学びました。\n\n- https://github.com/YTakahashii/redux-essentials-example-app-ts\n\nRedux Essentials は、全 8 回に渡る内容で、結構ボリューミーだったため、今回は Part1 と第して、第 1 回〜第 6 回までから得た学びをピックアップしてまとめます。\n\n- [Redux Essentials, Part 1: Redux Overview and Concepts](https://redux.js.org/tutorials/essentials/part-1-overview-concepts)\n- [Redux Essentials, Part 2: Redux App Structure](https://redux.js.org/tutorials/essentials/part-2-app-structure)\n- [Redux Essentials, Part 3: Basic Redux Data Flow](https://redux.js.org/tutorials/essentials/part-3-data-flow)\n- [Redux Essentials, Part 4: Using Redux Data](https://redux.js.org/tutorials/essentials/part-4-using-data)\n- [Redux Essentials, Part 5: Async Logic and Data Fetching](https://redux.js.org/tutorials/essentials/part-5-async-logic)\n- [Redux Essentials, Part 6: Performance and Normalizing Data](https://redux.js.org/tutorials/essentials/part-6-performance-normalization)\n\n## 1. どのような状況で Redux を使うべきか\n\n[Part 1: Redux Overview and Concepts の When Should I Use Redux?](https://redux.js.org/tutorials/essentials/part-1-overview-concepts#when-should-i-use-redux)に、Redux が役立つ状況は以下の 4 つであることが述べられていました。\n\n- アプリ内の多くの場所で必要とされる大量の State がある場合\n- State が時間の経過とともに頻繁に更新される場合\n- State を更新するロジックが複雑な場合\n- アプリのコードベースが中規模または大規模で、多くの人が作業する可能性がある場合\n\n「このデータは Redux で管理すべきか」を考えるときに、「アプリ内で多く参照されること」以外にも、state の更新頻度、複雑性、規模感も重要であることを明確に理解できました。\n\n## 2. redux-toolkit を使った Modern Redux\n\nRedux Essentials の Part 3 からは、ユーザが記事を投稿できるサンプルアプリの開発を通して、redux-toolkit を使った Redux アプリの構築を学びます。\n代表的な API は以下の 3 つです。\n\n- `createSlice()`\n- `createAsyncThunk()`\n- `createEntityAdapter()`\n\n以下は、これらの API の要約です。\n\n### createSlice() で Reducer に 集中したコードを書ける\n\n`createSlice()` は `reducers` で定義された Reducer を元に、Action や ActionCreator を自動生成してくれます。\n\n```ts\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    postAdded: {\n      reducer: (state, action: PayloadAction<Post>) => {\n        // note: prepare -> reducer\n        state.push(action.payload);\n      },\n      prepare: ({ title, content, userId }: Pick<Post, 'title' | 'content'> & { userId: string }) => {\n        // note: action creator相当のfunction\n        // note: reduxはpostsSlice.actions.postAdded({ title, content }) がdispatchされるとprepareを実行し、reducerのactionに受け渡す\n        return {\n          payload: {\n            id: nanoid(),\n            title,\n            content,\n            user: userId,\n            date: new Date().toISOString(),\n            reactions: initialReactions,\n          },\n        };\n      },\n    },\n  },\n});\n\nexport const { postAdded } = postsSlice.actions;\nexport default postsSlice.reducer;\n```\n\nRedux のしんどかった要素として、Action や ActionCreator 等のボイラープレートの記述がだるい問題がありましたが、slice を使用することで解決できます。\n\nAction は、React 内では、`dispatch(postAdded({ title, content, userId }))` のように dispatch します。\nまた、`store.dispatch(initiate())` のように、store の初期化時に React の外で dispatch することもできます。\n\n手書き時代の ActionCreator 内部 で行っていたような処理は、`prepare()` を定義して実行することができます。\n\n`createSlice()` 内部では Immer が使用されているため、`state.push(action.payload)` のように Mutable に state の更新を記述できる点もポイントですね。\n\n### 非同期的な state の更新は createAsyncThunk() で簡単に書ける\n\nデータのフェッチ等の非同期処理は `createAsyncThunk()` を使います。\n\n```ts\nexport const fetchPosts = createAsyncThunk('posts/fetchPosts', async () => {\n  const response = await client.get('/fakeApi/posts');\n  return response.data as Post[];\n});\n\nconst postsSlice = createSlice({\n  //省略\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchPosts.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(fetchPosts.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        state.posts = state.posts.concat(action.payload);\n      })\n      .addCase(fetchPosts.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message ?? null;\n      });\n  },\n});\n```\n\n`createSlice()` の外部で定義された ActionCreator に紐づく reducer は `extraReducers` で定義します。\nTypeScript で記述する場合は `builder.addCase()` 使って `state` と `action` の型を推論させる必要があります。\n\n`createAsyncThunk()` で生成した thunk は `pending/fulfilled/rejected` パターンを dispatch するので、必要に応じてそれぞれの reducer を定義します。\n\n### データの正規化は createEntityAdapter() にお任せ\n\nデータを正規化したい場合は、 `createEntityAdapter()` を使います。\nデフォルトでは、 `{ ids: [], entities: { [id]: value } }` の形式で変換されます。\n\n```ts\nconst postsAdapter = createEntityAdapter<Post>({\n  sortComparer: (a, b) => b.date.localeCompare(a.date),\n});\n\nconst initialState = postsAdapter.getInitialState<AsyncState>({\n  status: 'idle',\n  error: null,\n});\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    // 省略\n  },\n  extraReducers: (builder) => {\n    builder.addCase(fetchPosts.fulfilled, (state, action) => {\n      state.status = 'succeeded';\n      postsAdapter.upsertMany(state, action.payload);\n    });\n    builder.addCase(addNewPost.fulfilled, postsAdapter.addOne);\n  },\n});\n\nexport const {\n  selectAll: selectAllPosts,\n  selectById: selectPostById,\n  selectIds: selectPostIds,\n} = postsAdapter.getSelectors<RootState>((state) => state.posts);\n```\n\nadapter の役割は、データの正規化、正規化データの更新メソッドの提供、ids のソート、initialState の提供、selector の提供等、多岐に渡ります。\n\n`getSelectors()` で取得できる selector は Reselect によってメモ化されているのも嬉しいポイントです。\n\n手書き時代の Redux では、データの正規化のために`normalizr`による変換処理を定義する必要がありましたが、adapter にすべてが集約されていて開発者体験がとても良くなった印象です。\n\n## 3. React のレンダリングパフォーマンスの最適化\n\n[Redux Essentials, Part 6: Performance and Normalizing Data](https://redux.js.org/tutorials/essentials/part-6-performance-normalization) では、React のレンダリングパフォーマンスを向上するための手法が丁寧に解説されており、非常に学びになりました。\n\n### コンポーネントを React.memo() でラップする\n\n以下のように、親コンポーネントがリストデータを配列で持っている場合、その中の要素 1 つが更新されると配列全体が更新されてしまうため、結果的にリスト全体の再レンダリングが発生してしまいます。\n\nこれは、親コンポーネントが再レンダリングされると、子コンポーネントも再レンダリングしてしまうため、一つのアイテムを更新したのにも関わらず、リスト全体が再レンダリングされてしまうためです。\n\n子コンポーネントを `React.memo()` でラップすることで、更新がなかった子コンポーネントは再レンダリングを回避することができます。\n\nただし、`<PostsList />` は `posts` が変わってしまうため再レンダリングを回避できないことに注意する必要があります。\n\n```tsx\nconst PostExcerpt: React.NamedExoticComponent<{ post: Post }> = React.memo(({ post }) => (\n  <article className=\"post-excerpt\">\n    <h3>{post.title}</h3>\n    <div>\n      <PostAuthor userId={post.user} />\n      <TimeAgo timestamp={post.date} />\n    </div>\n    <p className=\"post-content\">{post.content.substring(0, 100)}</p>\n    <ReactionButtons post={post} />\n    <Link to={`/posts/${post.id}`} className=\"button muted-button\">\n      View Post\n    </Link>\n  </article>\n));\n\nexport const PostsList: React.VFC = () => {\n  const posts = useTypedSelector(selectAllPosts);\n  const postStatus = useTypedSelector((state) => state.posts.status);\n  const error = useTypedSelector((state) => state.posts.error);\n\n  const orderedPosts = useMemo(\n    () => (postStatus === 'succeeded' ? posts.slice().sort((a, b) => b.date.localeCompare(a.date)) : posts),\n    [postStatus, posts]\n  );\n\n  return (\n    <section className=\"posts-list\">\n      <h2>Posts</h2>\n      {postStatus === 'loading' ? (\n        <Spinner text=\"loading...\" />\n      ) : postStatus === 'succeeded' ? (\n        orderedPosts.map((post) => <PostExcerpt key={post.id} post={post} />)\n      ) : postStatus === 'failed' ? (\n        <div>{error}</div>\n      ) : null}\n    </section>\n  );\n};\n```\n\n### リストの親コンポーネントではアイテムの ids 配列だけを参照する\n\nリストデータを正規化することのメリットの一つは、リスト型コンポーネントのアイテムが更新される際に、リストの親コンポーネントの再レンダリングを防ぐことが可能なことです。\n\n上述の `posts` を正規化することで、親の `<PostsList />` は ids だけを参照すれば良くなり、アイテムの一部の値が更新されても `id` が更新されない限りは再レンダリングされなくなります。\n\n```tsx\nconst PostExcerpt: React.VFC<{ postId: EntityId }> = ({ postId }) => {\n  const post = useTypedSelector((state) => selectPostById(state, postId));\n\n  if (!post) {\n    return <div>Post not found.</div>;\n  }\n\n  return (\n    <article className=\"post-excerpt\">\n      <h3>{post.title}</h3>\n      <div>\n        <PostAuthor userId={post.user} />\n        <TimeAgo timestamp={post.date} />\n      </div>\n      <p className=\"post-content\">{post.content.substring(0, 100)}</p>\n      <ReactionButtons post={post} />\n      <Link to={`/posts/${post.id}`} className=\"button muted-button\">\n        View Post\n      </Link>\n    </article>\n  );\n};\n\nexport const PostsList: React.VFC = () => {\n  const dispatch = useTypedDispatch();\n  const orderedPostIds = useTypedSelector(selectPostIds);\n  const postStatus = useTypedSelector((state) => state.posts.status);\n  const error = useTypedSelector((state) => state.posts.error);\n\n  return (\n    <section className=\"posts-list\">\n      <h2>Posts</h2>\n      {postStatus === 'loading' ? (\n        <Spinner text=\"loading...\" />\n      ) : postStatus === 'succeeded' ? (\n        orderedPostIds.map((postId) => <PostExcerpt key={postId} postId={postId} />)\n      ) : postStatus === 'failed' ? (\n        <div>{error}</div>\n      ) : null}\n    </section>\n  );\n};\n```\n\n### メモ化されたセレクタ関数を useSelector に渡す\n\n`useSelector()` は Action が dispatch されるたびに再実行され、そこで新しい参照値を返すとコンポーネントが再レンダリングされます。\n\nselect 関数で配列やオブジェクトが生成される場合は、値の内容が変化していなくても常に新しい参照値となってしまうため、不要な再レンダリングを発生させてしまいます。\n\n例えば、下記の`<UserPage />` で計算されている`postsForUser` は `allPosts.filter()` によって常に新しい参照が返されてしまうので、どこかしらで Action が dispatch される度に、`<UserPage />`は再レンダリングしてしまいます。\n\n```tsx\nexport const UserPage: React.VFC<Props> = ({ match }) => {\n  const { userId } = match.params;\n\n  const user = useTypedSelector((state) => selectUserById(state, userId));\n\n  const postsForUser = useTypedSelector((state) => {\n    const allPosts = selectAllPosts(state);\n    return allPosts.filter((post) => post.user === userId);\n  });\n\n  // 省略\n};\n```\n\nこれを解決するためには、メモ化されたセレクタ関数を `useSelector()` に渡す必要があります。\nredux-toolkit では、セレクタ関数をメモ化するための `createSelector()` が提供されており、上記の `postsForUser` の セレクタは下記のようにメモ化することができます。\n\n```ts\nexport const selectPostsByUser = createSelector(\n  [selectAllPosts, selector((_, userId: string) => userId)], // input selectors\n  (posts, userId) => posts.filter((post) => post.user === userId) // output selector\n);\n```\n\n`createSelector()` の第一引数は input selectors 配列で、メモ化対象の値を返します。\n第二引数は output selector で、input selector の配列が順に引数として渡される関数です。\noutput selector で return した値がこのセレクタが返す値となります。\nこうすることで、`posts` か `userId` のどちらかが変化したときのみ、新しい参照が返されるため、結果として、不要な再レンダリングを防ぐことができます。\n\n上記の`selector((_, userId: string) => userId)` 内の`selector()`は、自分で定義した util 関数です。\nTS で純粋なセレクタを記述するときに、第一引数の`RootState`の型を省略できます。\n\n```ts\n// src/app/selector.ts\nimport { RootState } from './store';\n\ntype Extras<T extends unknown[]> = T extends [RootState, ...infer Extras] ? Extras : [];\n\nexport const selector = <T extends (state: RootState, ...extras: any[]) => unknown>(\n  select: T\n): T extends (...params: infer Params) => infer Return\n  ? (state: Params[0], ...extras: Extras<Params>) => Return\n  : never => select as any;\n```\n\n## おわりに\n\nRedux Essentials を読むことで、Redux 公式の推奨アプローチや React のレンダリングパフォーマンスの最適化について学ぶことができました。\n\nredux-toolkit を使ったコードは、ボイラープレートなコードをすべて手書きで書いていた頃と比べて、格段に少ない記述量で書くことができます。しかし、非同期処理の扱いは `pending/fulfilled/rejected` パターンを reducer に記述しなければならず、現代の hooks ベースの API（Apollo 等）と比較するとまだ冗長であると感じます。\n\n次回は、Part2 ということで、そこら辺の悩みも解決できる RTK Query についての学びをまとめようと思います。\n\n（ブログ作っただけで終わりにならなくて良かった〜〜〜〜）\n","url":"https://ytakahashii.github.io/blog/lerning-from-redux-essentials-part1","isPrivate":false},{"slug":"opening-a-blog","title":"Next.jsで技術ブログを作った話","publishDate":"2021-08-15","coverImage":"","excerpt":"Next.jsを使って技術ブログを作りました。使用した技術スタックと実装や学びについて共有します。","ogImage":{"url":"https://og-image-for-blog.vercel.app/**Next.jsで技術ブログを作った話**.png?theme=light&md=1&fontSize=100px"},"content":"\n**世はまさに、自作技術ブログ時代！** という訳で、Next.js 等を使って技術ブログを作りました。\n\n一旦、きりの良いところまで実装が終わったので、公開しようと思います！\n\nこのブログでは、趣味で触った技術のことについて、ざっくばらんに記事を投稿していく予定です。\nまた、私は Web Frontend が好きなので、関連技術の実験場にも活用していきます。\n\nゴールデンウィークから作り始めて、休日にちまちまやっていたので、随分時間がかかってしまいましたが、いい感じに仕上がってとりあえず満足しています。\n\n```twitter\n1389551048017080322\n```\n\n以降のセクションでは、技術スタックと、実装に一番の時間を要した Markdown ファイルから React コンポーネントに変換するまでの処理の詳細について振り返ります。\n\n## 技術スタック\n\n本ブログの開発に使用した技術は以下の通りです。（みんな使ってそうな構成）\n\n- [Next.js](https://nextjs.org/)：言わずと知れた React のフレームワーク\n- [Chakra UI](https://chakra-ui.com/)：tailwind like に React コンポーネントのスタイリングができるコンポーネントライブラリ\n- [jonschlinkert/gray-matter](https://github.com/jonschlinkert/gray-matter)：Markdown に yaml でメタ情報を埋め込めるやつ\n- [unifiedjs/unified](https://github.com/unifiedjs/unified)：構文木を使用してテキストを処理するためのインターフェース\n- [shiki](https://shiki.matsu.io/)：コードハイライター\n- [vercel/og-image](https://github.com/vercel/og-image)：OGP 画像の生成\n- [GitHub Pages](https://pages.github.com/)：サイトのホスティング\n\n## やったこと＆学び\n\n最初のゴールとして、Markdown から記事を生成可能かつ、それを見てもらうための最低限の機能に絞って開発を進めました。\nやったことを大別すると以下の 3 つになるのかなと思います。\n\n- Markdown ファイルからの記事ページ生成とレイアウト設定\n  - MD を変換する処理を実装することで、構文木の世界を学べた\n- プライベート記事機能\n  - [ブログのトップページ](/)や Google 検索の結果に載せないプライベート記事（例：[Playground](/_playground)）を公開する機能\n- メタタグの設定\n  - これまで業務的な Web アプリばかりを開発してきたため、学びが多かった\n\n## Markdown ファイルの内容を React コンポーネントに変換する\n\n### 1．Next.js で全 Markdown ファイルを取得して記事ページを生成する\n\n記事ページの生成は Next.js の SSG を使います。\n\n具体的には、[pages/[slug].tsx](https://github.com/YTakahashii/blog/blob/573224fa61a263d26c861aaea6696ad22f0a5469/src/pages/%5Bslug%5D.tsx#L1)内で、 `getStaticPaths` を使って Markdown のファイル名から記事ページの URL を生成し、\n\n```tsx\nexport const getStaticPaths: GetStaticPaths<Params> = async () => {\n  const posts = getAllPosts('all');\n\n  return {\n    paths: posts.map((post) => ({\n      params: {\n        slug: post.slug,\n      },\n    })),\n    fallback: false,\n  };\n};\n```\n\n`getStaticProps` を使って render する 記事の情報を取得し、Page コンポーネントの Props として渡します。\n\n```tsx\nexport const getStaticProps: GetStaticProps<{ post: Post }, Params> = async ({ params }) => {\n  const post = getPostBySlug(params.slug);\n\n  const html = await markdownToHtml(post.content ?? '');\n\n  return {\n    props: {\n      post: {\n        ...post,\n        content: html,\n      },\n    },\n  };\n};\n```\n\n### 2．unified で Markdown を整形して HTML の文字列に変換する\n\n上記の `getPostBySlug()` では、Markdown ファイルの中身（`post.content`）を文字列で取得します。\n\n続く`markdownToHtml()`では、`unified` を使って、ファイルの中身を HTML の文字列に変換していきます。\n\n```ts\nexport async function markdownToHtml(markdown: string) {\n  const result = unified()\n    .use(remarkParse)\n    .use(remarkRehype, { allowDangerousHtml: true })\n    .use(rehypeRaw)\n    .use(rehypeShiki, {\n      highlighter: await getHighlighter({\n        theme: 'github-dark',\n      }),\n    })\n    .use(rehypeStringify)\n    .processSync(markdown);\n\n  return result.toString();\n}\n```\n\n変換処理の概要は以下の通りです。\n\n- `remarkParse`：Markdown の文字列を[mdast](https://github.com/syntax-tree/mdast)（Markdown Abstract Syntax Tree format）に変換する\n- `remarkRehype`：mdast を [hast](https://github.com/syntax-tree/hast)（Hypertext Abstract Syntax Tree format）に変換する，`{ allowDangerousHtml: true }` により、生の HTML はそのまま残す\n- `rehypeRaw`：hast 内の生 HTML を hast に変換する\n- `rehypeShiki`：コードハイライターの shiki を使って 複数行のコードブロック をハイライトするスタイルを適用する\n- `rehypeStringify`：hast を HTML の文字列に変換する\n\n### 3．HTML の文字列を React コンポーネントに変換する\n\n最後に `markdownToHtml()` で取得した HTML 文字列を [remarkjs/react-markdown](https://github.com/remarkjs/react-markdown)を使って React コンポーネントに変換します。（[components/markdowns/Markdown.tsx](https://github.com/YTakahashii/blog/blob/main/src/components/markdowns/Markdown.tsx)）\n\n```tsx\nimport ReactMarkdown from 'react-markdown';\nimport rehypeRaw from 'rehype-raw';\nimport * as components from 'src/components/markdowns/_components';\n\n...\n\nexport const Markdown: React.VFC<Props> = ({ rawHtml }) => (\n  <ReactMarkdown rehypePlugins={[rehypeRaw]} children={rawHtml} components={components} />\n);\n```\n\nこのとき、`components` に React コンポーネントを渡すことで、任意のタグを自由に変換することができます。今回は、変換するコンポーネントを[components/markdowns/\\_components](https://github.com/YTakahashii/blog/tree/main/src/components/markdowns/_components)の中に定義しました。\n\n変換する対象は、[`<table />`](https://github.com/YTakahashii/blog/blob/573224fa61a263d26c861aaea6696ad22f0a5469/src/components/markdowns/_components/table.tsx#L1)のように、Chakra UI のコンポーネントに置き換えるタグと、[`<a />`](https://github.com/YTakahashii/blog/blob/573224fa61a263d26c861aaea6696ad22f0a5469/src/components/markdowns/_components/a.tsx#L1)のように、Props に応じて、レンダリングするコンポーネントを出し分けるタグです。\n\nスタイルだけ当てたいタグについてはここでは変換せず、 [Chakra UI のテーマを設定](https://github.com/YTakahashii/blog/blob/main/src/theme/index.ts)しました。\n\nまた、今回は変換対象の文字列（`children`）が HTML の形式であるため、`rehypePlugins` に `rehypeRaw` を指定して、hast に変換する処理を加える必要がありました。ピュアな MD 形式の文字列である場合は、`rehypeRaw` は不要です。\n\n## 今後実装したい機能\n\n- タグ機能\n  - 記事が増えていくにつれて探すのが大変になりそうなので、そのうち実装したいお気持ち\n- 目次機能\n  - この記事みて思ったけど、やっぱり目次あったほうが見やすいですね\n- ダークモードや PWA\n  - 新しい Web の機能をどんどん使っていきたいお気持ち\n- カッコいい OGP 画像の作成\n  - 今のデザインが超適当なので、どこかで気合を入れて作り込みたい\n\n## おわりに\n\nこれからは、ブログをもっと良くしたり、学んだ内容を定期的にアウトプットしていきたいと思います！\n\n最初は、「ブログなんて今更自分で作ってもな〜」とか思ってたのですが、車輪の再発明をすることで学べることも多いなと感じました。\n","url":"https://ytakahashii.github.io/blog/opening-a-blog","isPrivate":false}]},"__N_SSG":true}